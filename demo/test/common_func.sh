# Use this for capturing output from a function
function_output=""

token_sort()
{
  # Example usage: token_sort() ccc ggg bbb aaa
  # Example output: aaa bbb ccc ggg
  # Sorted output string is placed in 'function_output'

  function_output=$(echo "${@}" | xargs -n1 | sort | xargs)
}

addprefix()
{
  # Example usage: addprefix -I aaa bbb ccc
  # Example result: -Iaaa -Ibbb -Iccc
  # Function return value is placed in 'function_output'

  PREFIX="${1}"; shift
  function_output=""
  while [ "${#}" -ne "0" ]; do
    if [ -n "${function_output}" ]; then
      function_output="${function_output} ${PREFIX}${1}"
    else
      function_output="${PREFIX}${1}"
    fi

    shift
  done
}

update_compile_and_link_command()
{
  # Example usage: update_compile_and_link_command debug
  # Update the compile and link command variables depending
  #  on which build configuration (debug/release) is selected.

  BUILD_CONFIG="${1}"

  OBJ_DIR="${BUILD_DIR}/${BUILD_CONFIG}/obj"
  COMPILE_COMMAND="${CC} ${CPPFLAGS} ${CFLAGS} -c -o"
  LINK_COMMAND="${CC} ${OBJ_DIR}/main.o ${OBJ_DIR}/a.o ${OBJ_DIR}/b.o -o ${BUILD_DIR}/${BUILD_CONFIG}/${EXE}"
  if [ "${BUILD_CONFIG}" = "debug" ]; then
    COMPILE_COMMAND="${COMPILE_COMMAND} ${DEBUG_CFLAGS} ${DEBUG_CPPFLAGS}"
  else
    COMPILE_COMMAND="${COMPILE_COMMAND} ${RELEASE_CFLAGS} ${RELEASE_CPPFLAGS}"
  fi
}

generate_expected_make_output()
{
  # Example usage: generate_expected_make_output include/a.h
  # Example result: compile and link commands that are expected
  #  to be generated by Make after the specified files have been
  #  updated.
  # Output will be written to temporary file expected_output.$$
  # The 'function_output' will also be set to the number of lines
  #  expected (compiler + linker commands) from running Make.
  # If the provided source file is 'all', this function will
  #  return the expected make output from running an unconditional
  #  'make all' command.
  # The expected_output from this function must be generated in
  #  the same order that the make command will generate them to
  #  allow for a proper comparison between the commands.

  if [ -f expected_output.$$ ]; then rm expected_output.$$; fi
  touch expected_output.$$

  case "${1}" in
    "src/main.c")
      printf "${COMPILE_COMMAND} src/main.c ${OBJ_DIR}/main.o\n" >> expected_output.$$
      printf "${LINK_COMMAND}\n" >> expected_output.$$
      function_output='2'
      ;;
    "include/a.h")
      printf "${COMPILE_COMMAND} src/main.c ${OBJ_DIR}/main.o\n" >> expected_output.$$
      printf "${COMPILE_COMMAND} src/a.c ${OBJ_DIR}/a.o\n" >> expected_output.$$
      printf "${LINK_COMMAND}\n" >> expected_output.$$
      function_output='3'
      ;;
    "include/b.h")
      printf "${COMPILE_COMMAND} src/main.c ${OBJ_DIR}/main.o\n" >> expected_output.$$
      printf "${COMPILE_COMMAND} src/b.c ${OBJ_DIR}/b.o\n" >> expected_output.$$
      printf "${LINK_COMMAND}\n" >> expected_output.$$
      function_output='3'
      ;;
    "src/a.c")
      printf "${COMPILE_COMMAND} src/a.c ${OBJ_DIR}/a.o\n" >> expected_output.$$
      printf "${LINK_COMMAND}\n" >> expected_output.$$
      function_output='2'
      ;;
    "src/b.c")
      printf "${COMPILE_COMMAND} src/b.c ${OBJ_DIR}/b.o\n" >> expected_output.$$
      printf "${LINK_COMMAND}\n" >> expected_output.$$
      function_output='2'
      ;;
    "all")
      printf "${COMPILE_COMMAND} src/main.c ${OBJ_DIR}/main.o\n" >> expected_output.$$
      printf "${COMPILE_COMMAND} src/a.c ${OBJ_DIR}/a.o\n" >> expected_output.$$
      printf "${COMPILE_COMMAND} src/b.c ${OBJ_DIR}/b.o\n" >> expected_output.$$
      printf "${LINK_COMMAND}\n" >> expected_output.$$
      function_output='4'
      ;;
  esac
}

test_file_recompilation()
{
  # Example usage: test_file_compilation debug src/a.c
  # Given a single input source or header file, this function
  #  will update the modified time of this file (via the touch
  #  command) and run the make target. If the proper files are
  #  recompiled, it's considered a success. Otherwise, an error
  #  message is printed and the script will exit.
  # If the source file is specified as 'all', then this function
  #  will unconditionally make the provided target.

  update_compile_and_link_command "${1}"

  SOURCE="${2}"
  generate_expected_make_output "${SOURCE}"
  NUM_LINES_EXPECTED="${function_output}"

  if [ "${SOURCE}" != "all" ]; then
    touch "${SOURCE}"
    sleep 1
    MAKE_OUTPUT=$(make "${1}")
  else
    MAKE_OUTPUT=$(make -B "${1}")
  fi

  NUM_LINES_ACTUAL=$(echo "${MAKE_OUTPUT}" | wc -l)

  if [ "${NUM_LINES_ACTUAL}" -ne "${NUM_LINES_EXPECTED}" ]; then
    printf "Expected lines of output: ${NUM_LINES_EXPECTED}\n"
    printf "Actual lines of output: ${NUM_LINES_ACTUAL}\n"
    printf "Test: ${RED}FAILED${DEF}\n"
    exit 1
  fi

  loop_num='1'

  echo "${MAKE_OUTPUT}" |
  while read line; do
    token_sort "${line}"
    line_sorted="${function_output}"

    expected=$(sed -n "${loop_num}p" expected_output.$$)
    token_sort "${expected}"
    expected_sorted="${function_output}"

    if [ "${line_sorted}" = "${expected_sorted}" ]; then
      printf "(${GRN}pass${DEF}) ${line}\n"
    else
      printf "Expected command line: ${expected_sorted}\n"
      printf "Actual command line: ${line_sorted}\n"
      printf "Test: ${RED}FAILED${DEF}\n"
      exit 1
    fi

    loop_num=$(expr "${loop_num}" + 1)
  done

  printf "Test: ${GRN}PASSED${DEF}\n"
}
